"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildXmlElement = exports.writeXML = exports.parseXML = exports.readXML = void 0;
/* eslint-disable unicorn/catch-error-name */
const xml2js = require("xml2js");
const fs_1 = require("./fs");
async function readXML(path) {
    var _a;
    try {
        const xmlStr = await (0, fs_1.readFile)(path, { encoding: 'utf-8' });
        try {
            return await xml2js.parseStringPromise(xmlStr);
        }
        catch (e) {
            throw `Error parsing: ${path}, ${(_a = e.stack) !== null && _a !== void 0 ? _a : e}`;
        }
    }
    catch {
        throw `Unable to read: ${path}`;
    }
}
exports.readXML = readXML;
function parseXML(xmlStr, options) {
    const parser = 
    // eslint-disable-next-line no-negated-condition
    options !== undefined ? new xml2js.Parser({ ...options }) : new xml2js.Parser();
    let xmlObj;
    parser.parseString(xmlStr, (err, result) => {
        if (!err) {
            xmlObj = result;
        }
    });
    return xmlObj;
}
exports.parseXML = parseXML;
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
async function writeXML(object) {
    return new Promise((resolve) => {
        const builder = new xml2js.Builder({
            headless: true,
            explicitRoot: false,
            rootName: 'deleteme',
        });
        let xml = builder.buildObject(object);
        xml = xml.replace('<deleteme>', '').replace('</deleteme>', '');
        resolve(xml);
    });
}
exports.writeXML = writeXML;
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function buildXmlElement(configElement, rootName) {
    const builder = new xml2js.Builder({
        headless: true,
        explicitRoot: false,
        rootName: rootName,
    });
    return builder.buildObject(configElement);
}
exports.buildXmlElement = buildXmlElement;
