"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.download = exports.createRequest = exports.ContentType = void 0;
var ContentType;
(function (ContentType) {
    ContentType["JSON"] = "application/json";
    ContentType["FORM_URLENCODED"] = "application/x-www-form-urlencoded";
    ContentType["HTML"] = "text/html";
})(ContentType = exports.ContentType || (exports.ContentType = {}));
async function createRequest(method, url, { userAgent, disabledTLSCerts }) {
    const superagent = await Promise.resolve().then(() => require('superagent'));
    const req = superagent(method, url);
    if (disabledTLSCerts) {
        req.disableTLSCerts();
    }
    req.set('User-Agent', userAgent).redirects(25);
    // if (ssl) {
    //   const cafiles = conform(ssl.cafile)
    //   const certfiles = conform(ssl.certfile)
    //   const keyfiles = conform(ssl.keyfile)
    //   if (cafiles.length > 0) {
    //     req.ca(
    //       await Promise.all(cafiles.map((p) => readFile(p, { encoding: 'utf8' })))
    //     )
    //   }
    //   if (certfiles.length > 0) {
    //     req.cert(
    //       await Promise.all(
    //         certfiles.map((p) => readFile(p, { encoding: 'utf8' }))
    //       )
    //     )
    //   }
    //   if (keyfiles.length > 0) {
    //     req.key(
    //       await Promise.all(
    //         keyfiles.map((p) => readFile(p, { encoding: 'utf8' }))
    //       )
    //     )
    //   }
    // }
    return { req };
}
exports.createRequest = createRequest;
/**
 * Initiate a request, downloading the contents to a writable stream.
 *
 * @param req The request to download to the writable stream.
 * @param ws Must be a dedicated writable stream that calls the 'close' event.
 * @return Promise<void>
 */
async function download(req, ws, { progress }) {
    return new Promise((resolve, reject) => {
        req
            .on('response', (res) => {
            if (res.status !== 200) {
                reject(new Error(`Encountered bad status code (${res.status}) for ${req.url}\n` +
                    `This could mean the server is experiencing difficulties right now--please try again later.`));
            }
            if (progress) {
                let loaded = 0;
                const total = Number(res.header['content-length']);
                res.on('data', (chunk) => {
                    loaded += chunk.length;
                    progress(loaded, total);
                });
            }
        })
            .on('error', (err) => {
            if (err.code === 'ECONNABORTED') {
                reject(new Error(`Timeout of ${err.timeout}ms reached for ${req.url}`));
            }
            else {
                reject(err);
            }
        });
        ws.on('close', resolve);
        req.pipe(ws);
    });
}
exports.download = download;
