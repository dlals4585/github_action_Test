"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.syncLibraryManifest = exports.applyLegacyWebLibrary = exports.applyIosLibrary = exports.applyAndroidLibrary = exports.loadInstalledLibrary = exports.promptLibraries = exports.loadLibraries = exports.trasferSortNum = exports.validateLibraryLabel = void 0;
const path = require("node:path");
const definition_1 = require("../definition");
const errors_1 = require("../errors");
const fs_1 = require("./utils/fs");
const prompt_1 = require("./prompt");
const guards_1 = require("../guards");
const xml_1 = require("./utils/xml");
const npm_1 = require("./npm");
function validateLibraryLabel(name) {
    return name.includes('core') || name.includes('addon') || name.includes('trd') || name.includes('plugin');
}
exports.validateLibraryLabel = validateLibraryLabel;
function trasferSortNum(file) {
    if (file.includes('core'))
        return 2;
    return file.includes('addon') ? 1 : 0;
}
exports.trasferSortNum = trasferSortNum;
async function loadLibraries(cliConfig) {
    const scopeName = definition_1.PACKAGE_GROUP_NAME.replace('@', '');
    const data = await (0, npm_1.searchNpmPackagesByScope)(scopeName, cliConfig);
    const promises = data.objects
        .filter((o) => validateLibraryLabel(o.package.name))
        .map((o) => {
        return (0, npm_1.searchNpmPackage)(`${definition_1.PACKAGE_GROUP_NAME}/${o.package.name}`, cliConfig);
    });
    const libraries = await Promise.all(promises);
    return libraries
        .map((p) => {
        const latest = p['dist-tags'].latest;
        return {
            description: p.description,
            name: p.name,
            version: latest,
            history: p.readme ? p.readme : p.versions[latest].readme || '',
        };
    })
        .sort((a, b) => trasferSortNum(b.name) - trasferSortNum(a.name));
}
exports.loadLibraries = loadLibraries;
async function promptLibraries(message, libraries, required = ['core']) {
    const _required = [];
    const options = libraries
        .sort((a, b) => trasferSortNum(b.name) - trasferSortNum(a.name))
        .map((value) => {
        const libName = value.name.split('/')[1];
        if (required.includes(libName))
            _required.push(value);
        return {
            name: `${libName} (${value.version})`,
            value,
            disabled: required.includes(libName) && 'required',
            checked: required.includes(libName),
        };
    });
    return [..._required, ...(await (0, prompt_1.multiChoice)(message, options))];
}
exports.promptLibraries = promptLibraries;
async function loadInstalledLibrary(config) {
    const groupDir = path.join(config.app.rootDir, 'node_modules', definition_1.PACKAGE_GROUP_NAME);
    if (!(await (0, fs_1.pathExists)(groupDir))) {
        throw new errors_1.FatalException('Can Not Found @morpheus library modules.. you must run command "npm install" ');
    }
    const files = await (0, fs_1.readdir)(groupDir, {
        withFileTypes: true,
    });
    return await Promise.all(files
        .filter((file) => file.isDirectory() && validateLibraryLabel(file.name))
        .sort((a, b) => trasferSortNum(b.name) - trasferSortNum(a.name))
        .map(async (file) => ({
        name: file.name,
        packageJson: await (0, fs_1.readJSON)(path.join(groupDir, file.name, 'package.json')),
    })));
}
exports.loadInstalledLibrary = loadInstalledLibrary;
async function loadInstalledIosLibrary(config) {
    const libraries = await loadInstalledLibrary(config);
    const result = [];
    for (const { packageJson } of libraries) {
        const { name: packageName } = packageJson;
        const pacakgePath = path.join(config.app.rootDir, 'node_modules', ...packageName.split('/'), 'ios');
        if (!(await (0, fs_1.pathExists)(pacakgePath)))
            continue;
        const files = await (0, fs_1.readdir)(pacakgePath);
        const podFileName = files.find((file) => file.includes('.podspec'));
        if (podFileName) {
            result.push({ packageName, podName: podFileName.split('.')[0] });
        }
    }
    return result;
}
async function applyAndroidLibrary(config) {
    const gradleFile = path.join(config.android.rootDir, 'morpheus.gradle');
    const libraries = await loadInstalledLibrary(config);
    const gradleHeader = '// !! DO NOT TOUCH THIS FILE \n';
    const gradleContent = libraries
        .map(({ name }) => `apply from: '../../node_modules/${definition_1.PACKAGE_GROUP_NAME}/${name}/android/library.gradle'`)
        .join('\n');
    await (0, fs_1.writeFile)(gradleFile, gradleHeader + gradleContent, { encoding: 'utf-8' });
}
exports.applyAndroidLibrary = applyAndroidLibrary;
async function applyIosLibrary(config) {
    // 임시 ios 프로젝트 정보가 없는 경우 수행하지 않는다.
    if (!config.ios)
        return;
    const podFile = path.join(config.ios.rootDir, 'Podfile');
    const libraries = await loadInstalledIosLibrary(config);
    const content = await (0, fs_1.readFile)(podFile, { encoding: 'utf-8' });
    const injectContent = 'def morpheus_pods\n' +
        libraries.map(({ podName, packageName }) => `  pod '${podName}', :path => '../../node_modules/${packageName}/ios'`).join('\n') +
        '\nend';
    const regex = /def\smorpheus_pods[\S\s]*?\nend/;
    const podFileContent = regex.test(content) ? content.replace(regex, injectContent) : content + injectContent;
    await (0, fs_1.writeFile)(podFile, podFileContent, { encoding: 'utf-8' });
}
exports.applyIosLibrary = applyIosLibrary;
async function applyLegacyWebLibrary(config) {
    const tragetPath = path.join(config.web.output, 'mcore.min.js');
    const libraries = await loadInstalledLibrary(config);
    const ws = (0, fs_1.createWriteStream)(tragetPath, { encoding: 'utf-8' });
    for (const library of libraries) {
        const inputFile = path.join(config.app.rootDir, 'node_modules', definition_1.PACKAGE_GROUP_NAME, library.name, 'legacy', 'index.js');
        if (!(await (0, fs_1.pathExists)(inputFile)))
            continue;
        await (0, fs_1.promifyStream)(ws, (0, fs_1.createReadStream)(inputFile, { encoding: 'utf-8' }));
        ws.write('\n');
        if (library.name === 'core') {
            const wnInterfaceFile = path.join(config.app.rootDir, 'node_modules', definition_1.PACKAGE_GROUP_NAME, library.name, 'legacy', 'wnInterface.js');
            if (await (0, fs_1.pathExists)(wnInterfaceFile)) {
                await (0, fs_1.copy)(wnInterfaceFile, path.join(config.web.output, 'wnInterface.js'));
            }
        }
    }
    ws.end();
}
exports.applyLegacyWebLibrary = applyLegacyWebLibrary;
async function syncLibraryManifest(config) {
    const manifestFile = config.app.manifest;
    if (!(await (0, fs_1.pathExists)(manifestFile)))
        throw new errors_1.FatalException(`can not found ${manifestFile}. \n`);
    const libraries = await loadInstalledLibrary(config);
    const libraryExt = config.app.manifestExt || 'mcore.mobile.app.implementation.ExtendWNInterface';
    let content = await (0, fs_1.readFile)(manifestFile, { encoding: 'utf-8' });
    const xmlObject = {
        library: [
            {
                ext: [libraryExt],
                addons: [{ path: [] }],
                plugins: [{ path: [] }],
            },
        ],
    };
    const addons = [];
    const plugins = [];
    for (const library of libraries) {
        if ((0, guards_1.isMorpheusPackage)(library.packageJson) && library.packageJson.morpheus.interface) {
            const { interface: interfaceStr } = library.packageJson.morpheus;
            library.name.includes('addon') ? addons.push(interfaceStr) : plugins.push(interfaceStr);
        }
    }
    xmlObject.library[0].addons[0].path = addons.filter(Boolean);
    xmlObject.library[0].plugins[0].path = plugins.filter(Boolean);
    const injectContent = await (0, xml_1.writeXML)(xmlObject);
    const regex = /<library>[\S\s]*?\s<\/library>/;
    content = content.replace(regex, injectContent.trim());
    await (0, fs_1.writeFile)(manifestFile, content, { encoding: 'utf-8' });
}
exports.syncLibraryManifest = syncLibraryManifest;
