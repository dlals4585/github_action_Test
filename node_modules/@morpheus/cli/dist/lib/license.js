"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readLicense = exports.addLicense = exports.applyIosLicense = exports.applyWebLicense = exports.applyAndroidLicense = exports.choiceAndroidCpus = exports.choiceAppLicense = exports.loadAndroidCpus = exports.getLicenseByAppId = exports.isExpireLicense = exports.loadUserLicenses = void 0;
const path = require("node:path");
const fs_1 = require("./utils/fs");
const debug_1 = require("debug");
const definition_1 = require("../definition");
const prompt_1 = require("./prompt");
const zip_1 = require("./utils/zip");
const errors_1 = require("../errors");
const guards_1 = require("../guards");
const debug = (0, debug_1.default)('cli:lib:license');
async function loadUserLicenses(cliConfig) {
    const licenses = [definition_1.EDUCATION_LICENSE];
    const userLicenseDir = path.join(cliConfig.dataDir, definition_1.LICENSE_DIR);
    if (!(await (0, fs_1.pathExists)(userLicenseDir)))
        return licenses;
    const files = await (0, fs_1.readdir)(userLicenseDir, {
        withFileTypes: true,
    });
    for (const file of files) {
        if (file.isDirectory()) {
            const licFile = path.join(userLicenseDir, file.name, definition_1.LICENSE_FILE_NAME);
            if (await (0, fs_1.pathExists)(licFile)) {
                try {
                    const license = await readLicense(licFile);
                    licenses.push(license);
                }
                catch (error) {
                    debug('ERROR: can not read license. \n %O', error);
                }
            }
        }
    }
    debug('license list : \n %O', licenses);
    return licenses;
}
exports.loadUserLicenses = loadUserLicenses;
function isExpireLicense(lic) {
    const now = Date.now();
    const expires = lic.expirationDate.split('-');
    const date = new Date();
    date.setFullYear(Number(expires[0]), Number(expires[1]) - 1, Number(expires[2]));
    date.setHours(0, 0, 0, 0);
    const expireTime = date.getTime();
    return expireTime < now;
}
exports.isExpireLicense = isExpireLicense;
async function getLicenseByAppId(cliConfig, appId) {
    const isEducation = appId.startsWith(definition_1.EDUCATION_APP_ID.replace(/\*/g, ''));
    if (isEducation) {
        return {
            ...definition_1.EDUCATION_LICENSE,
            packageName: appId,
            bundleId: appId,
        };
    }
    const licenses = await loadUserLicenses(cliConfig);
    const lic = licenses.find((l) => l.appId === appId);
    if (!lic)
        throw new errors_1.FatalException(`Can not Found License \n  APP ID : ${appId}`);
    if (isExpireLicense(lic))
        throw new errors_1.LicenseException(`"${appId}" License is Expired.`);
    return lic;
}
exports.getLicenseByAppId = getLicenseByAppId;
async function loadAndroidCpus(androidRootDir) {
    const licenses = [];
    const androidLibDir = path.join(androidRootDir, 'libs');
    if (!(await (0, fs_1.pathExists)(androidLibDir)))
        return licenses;
    const files = await (0, fs_1.readdir)(androidLibDir, {
        withFileTypes: true,
    });
    for (const file of files) {
        if (file.isDirectory() && (0, guards_1.isAndroidCpu)(file.name))
            licenses.push(file.name);
    }
    debug('license list : \n %O', licenses);
    return licenses;
}
exports.loadAndroidCpus = loadAndroidCpus;
async function choiceAppLicense(cliConfig, appId) {
    const licenses = await loadUserLicenses(cliConfig);
    const selectedLic = await (0, prompt_1.singleChoice)('앱 아이디를 선택해주세요.', licenses
        .map((lic) => {
        let disabled;
        if (lic.appId === appId && appId !== definition_1.EDUCATION_APP_ID) {
            disabled = 'selected';
        }
        else if (isExpireLicense(lic)) {
            disabled = 'expired';
        }
        return {
            name: `${lic.appId} (${lic.expirationDate})`,
            value: lic,
            disabled,
        };
    })
        .sort((a, b) => {
        if (a.disabled && b.disabled)
            return 0;
        return a.disabled ? 1 : -1;
    }), true);
    return selectedLic.appId === definition_1.EDUCATION_APP_ID ? await (0, prompt_1.promptEduAppPackage)() : selectedLic;
}
exports.choiceAppLicense = choiceAppLicense;
async function choiceAndroidCpus(cpus = []) {
    const options = Object.values(definition_1.ANDROID_CPU).map((cpu) => {
        return {
            checked: cpus.includes(cpu),
            disabled: false,
            name: cpu,
            value: cpu,
        };
    });
    return await (0, prompt_1.multiChoice)('안드로이드 CPU타입을 선택해주세요', options);
}
exports.choiceAndroidCpus = choiceAndroidCpus;
async function applyAndroidLicense(cpus, androidRootDir, license, { embedDir, dataDir }, replacer = '%ANDROID_PACKAGE_NAME%') {
    const destDir = path.join(androidRootDir, 'libs');
    const gradleFile = path.join(androidRootDir, 'build.gradle');
    let gradleContent = await (0, fs_1.readFile)(gradleFile, { encoding: 'utf-8' });
    gradleContent = gradleContent.replace(new RegExp(replacer, 'g'), license.packageName);
    await (0, fs_1.writeFile)(gradleFile, gradleContent, { encoding: 'utf-8' });
    const baseDir = license.appId === definition_1.EDUCATION_APP_ID
        ? path.join(embedDir, definition_1.EDU_LICENSE_DIR, 'android')
        : path.join(dataDir, definition_1.LICENSE_DIR, license.appId, 'android');
    if (!(await (0, fs_1.pathExists)(destDir))) {
        await (0, fs_1.mkdirp)(destDir);
    }
    for (const cpu of cpus) {
        const sourceDir = path.join(baseDir, cpu);
        if (await (0, fs_1.pathExists)(sourceDir)) {
            await (0, fs_1.copy)(sourceDir, path.join(destDir, cpu));
        }
        else {
            debug(`Empty Android License "${cpu}" path : ${sourceDir}`);
        }
    }
}
exports.applyAndroidLicense = applyAndroidLicense;
async function applyWebLicense(assetsDir, { appId }, { embedDir, dataDir }) {
    const filename = definition_1.LICENSE_FILE_NAME;
    const dest = path.join(assetsDir, 'res', filename);
    const src = appId === definition_1.EDUCATION_APP_ID ? path.join(embedDir, definition_1.EDU_LICENSE_DIR, filename) : path.join(dataDir, definition_1.LICENSE_DIR, appId, filename);
    await (0, fs_1.copyFile)(src, dest);
}
exports.applyWebLicense = applyWebLicense;
async function applyIosLicense(iosRootDir, { appId, bundleId }, { embedDir, dataDir }, replacer = '%BUNDLE_IDENTIFIER%') {
    const filename = 'MCore.license';
    const destDir = path.join(iosRootDir);
    const dest = path.join(destDir, filename);
    const files = await (0, fs_1.readdir)(iosRootDir, {
        withFileTypes: true,
    });
    for (const file of files) {
        if (file.isDirectory() && file.name.includes('.xcodeproj')) {
            const pbxprojFile = path.join(iosRootDir, file.name, 'project.pbxproj');
            let pbxprojContent = await (0, fs_1.readFile)(pbxprojFile, { encoding: 'utf-8' });
            pbxprojContent = pbxprojContent.replace(new RegExp(replacer, 'g'), bundleId);
            await (0, fs_1.writeFile)(pbxprojFile, pbxprojContent, { encoding: 'utf-8' });
        }
    }
    const src = appId === definition_1.EDUCATION_APP_ID
        ? path.join(embedDir, definition_1.EDU_LICENSE_DIR, 'ios', filename)
        : path.join(dataDir, definition_1.LICENSE_DIR, appId, 'ios', filename);
    if (!(await (0, fs_1.pathExists)(destDir)))
        await (0, fs_1.mkdirp)(destDir);
    await (0, fs_1.copyFile)(src, dest);
}
exports.applyIosLicense = applyIosLicense;
async function addLicense(zipFile, config) {
    const tempDirName = `${Date.now()}`;
    const licenseDir = path.join(config.dataDir, definition_1.LICENSE_DIR);
    const tempDir = path.join(licenseDir, tempDirName);
    try {
        await (0, zip_1.unzip)(zipFile, licenseDir, tempDirName);
        const licFile = path.join(tempDir, 'mcore.mobile.lic');
        const { appId } = await readLicense(licFile);
        const renameDir = path.join(licenseDir, appId);
        if (await (0, fs_1.pathExists)(renameDir))
            await (0, fs_1.remove)(renameDir);
        await (0, fs_1.rename)(tempDir, renameDir);
    }
    catch (err) {
        if (await (0, fs_1.pathExists)(tempDir))
            await (0, fs_1.remove)(tempDir);
        throw err;
    }
}
exports.addLicense = addLicense;
async function readLicense(licFile) {
    const content = await (0, fs_1.readFile)(licFile, { encoding: 'utf-8' });
    const lines = content.split('\n');
    let appId;
    let packageName;
    let bundleId;
    let expirationDate;
    for (const line of lines) {
        if (line.includes('application_id=')) {
            appId = line.replace('application_id=', '').trim();
        }
        else if (line.includes('namespace_mask=')) {
            const dummy = {};
            line
                .replace('namespace_mask=', '')
                .trim()
                .split(';')
                .filter(Boolean)
                // eslint-disable-next-line array-callback-return
                .map((m) => {
                const ms = m.split('@');
                dummy[ms[0]] = ms[1];
            });
            const { android, ios } = dummy;
            if (typeof android === 'string') {
                packageName = android;
            }
            if (typeof ios === 'string') {
                bundleId = ios;
            }
        }
        else if (line.includes('expiration_date=')) {
            expirationDate = line.replace('expiration_date=', '').trim();
        }
    }
    if (content.includes('namespace_mask=') === false) {
        // v2.5 이하 라이선스에서는 namespace_mask가 없음.
        // appId로 패키지네임, 번들ID로 사용함.
        packageName = appId;
        bundleId = appId;
    }
    if (!(appId && packageName && bundleId && expirationDate))
        throw new errors_1.InvalideLicenseException();
    return { appId, packageName, bundleId, expirationDate };
}
exports.readLicense = readLicense;
