"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyAppStartPage = exports.applyIosAppIcon = exports.applyAndroidAppIcon = exports.writeNpmrc = exports.writePackageJson = exports.applyIosProject = exports.applyIosAppName = exports.applyAndroidAppName = exports.installTemplate = exports.choiceTemplate = exports.fetchTemplateDownloadLink = exports.fetchTemplates = void 0;
const path = require("node:path");
const core_1 = require("@oclif/core");
const plist = require("plist");
const definition_1 = require("../definition");
const giteaService = require("./gitea");
const prompt_1 = require("./prompt");
const fs_1 = require("./utils/fs");
const superagent_1 = require("./utils/superagent");
const tar_1 = require("./utils/tar");
const errors_1 = require("../errors");
const npmServices = require("./npm");
async function fetchTemplates(cliConfig) {
    const mode = cliConfig.template.mode;
    const result = [];
    if (mode !== 'npm') {
        const _config = { template: cliConfig.template, package: cliConfig.package, disabledTLSCerts: cliConfig.disabledTLSCerts };
        const res = await giteaService.getTemplates(_config);
        const templates = res.map(({ name, description }) => ({ name, description, provider: 'gitea' }));
        result.push(...templates);
    }
    if (mode !== 'gitea') {
        const scope = cliConfig.template.npmPackageScope;
        const _config = {
            npmRegistryUrl: cliConfig.template.npmRegistryUrl,
            package: cliConfig.package,
            disabledTLSCerts: cliConfig.disabledTLSCerts,
        };
        const res = await npmServices.searchNpmPackagesByScope(scope.replace('@', ''), _config);
        const syncPackageName = (name) => (name.startsWith(scope) ? name.replace(`${scope}/`, '') : name);
        const templates = res.objects.map(({ package: { name, description } }) => ({
            name: syncPackageName(name),
            description,
            provider: 'npm',
        }));
        result.push(...templates);
    }
    return result;
}
exports.fetchTemplates = fetchTemplates;
async function fetchTemplateDownloadLink(template, cliConfig) {
    const mode = cliConfig.template.mode === 'all' ? template.provider : cliConfig.template.mode;
    const { version } = cliConfig.package;
    if (cliConfig.template.mode !== 'npm' && mode === 'gitea') {
        const { giteaBaseUrl, giteaTemplateOrg } = cliConfig.template;
        const res = await giteaService.getLatestRelease(template.name, {
            package: { version },
            template: { giteaBaseUrl, giteaTemplateOrg },
            disabledTLSCerts: cliConfig.disabledTLSCerts,
        });
        return res.tarball_url;
    }
    if (cliConfig.template.mode !== 'gitea' && mode === 'npm') {
        // npm search
        const { npmPackageScope, npmRegistryUrl } = cliConfig.template;
        const res = await npmServices.searchNpmPackage(`${npmPackageScope}/${template.name}`, {
            npmRegistryUrl,
            package: { version },
            disabledTLSCerts: cliConfig.disabledTLSCerts,
        });
        const latest = res['dist-tags'].latest;
        return res.versions[latest].dist.tarball;
    }
    throw new errors_1.FatalException('mismatch template provider and cli config');
}
exports.fetchTemplateDownloadLink = fetchTemplateDownloadLink;
async function choiceTemplate(cliConfig) {
    const templates = await fetchTemplates(cliConfig);
    return await (0, prompt_1.singleChoice)('템플릿을 선택해주세요', templates.map((t) => {
        return {
            name: cliConfig.template.mode === 'all' ? `${t.name} (${t.provider})` : t.name,
            value: t,
        };
    }));
}
exports.choiceTemplate = choiceTemplate;
async function installTemplate(template, destDir, config) {
    // const { tarball_url: downloadUrl } = await giteaService.getLatestRelease(templateName, 'cli' in config ? config.cli : config)
    const downloadUrl = await fetchTemplateDownloadLink(template, config);
    const { req } = await (0, superagent_1.createRequest)('GET', downloadUrl, {
        userAgent: `node/superagent/Morpheus CLI ${config.package.version}`,
        disabledTLSCerts: config.disabledTLSCerts,
    });
    // android app name
    core_1.ux.action.start('starting web project create..');
    await (0, tar_1.downloadAndUnzip)(req, destDir, {});
    core_1.ux.action.stop();
}
exports.installTemplate = installTemplate;
async function applyAndroidAppName(androidRootDir, appName) {
    const stringsXml = path.join(androidRootDir, 'src', 'main', 'res', 'values', 'strings.xml');
    const regex = /<string name="app_name">[\S\s]*?<\/string>/;
    let content = await (0, fs_1.readFile)(stringsXml, { encoding: 'utf-8' });
    content = content.replace(regex, `<string name="app_name">${appName}</string>`);
    await (0, fs_1.writeFile)(stringsXml, content, { encoding: 'utf-8' });
}
exports.applyAndroidAppName = applyAndroidAppName;
async function applyIosAppName(iosRootDir, appName) {
    const infoPlist = path.join(iosRootDir, 'Supporting Files', 'Info.plist');
    const info = plist.parse(await (0, fs_1.readFile)(infoPlist, { encoding: 'utf-8' }));
    info.CFBundleDisplayName = appName;
    await (0, fs_1.writeFile)(infoPlist, plist.build(info), { encoding: 'utf-8' });
}
exports.applyIosAppName = applyIosAppName;
async function applyIosProject(iosRootDir, projectName) {
    const xcodeprojDir = `${projectName}.xcodeproj`;
    await (0, fs_1.rename)(path.join(iosRootDir, '[PROJECT_NAME].xcodeproj'), path.join(iosRootDir, xcodeprojDir));
    const reg = /%PROJECT_NAME%/g;
    const podfile = path.join(iosRootDir, 'Podfile');
    let podfileContent = await (0, fs_1.readFile)(podfile, { encoding: 'utf-8' });
    podfileContent = podfileContent.replace(reg, projectName);
    await (0, fs_1.writeFile)(podfile, podfileContent, { encoding: 'utf-8' });
    const pbxproj = path.join(iosRootDir, xcodeprojDir, 'project.pbxproj');
    let pbxprojContent = await (0, fs_1.readFile)(pbxproj, { encoding: 'utf-8' });
    pbxprojContent = pbxprojContent.replace(reg, projectName);
    await (0, fs_1.writeFile)(pbxproj, pbxprojContent, { encoding: 'utf-8' });
}
exports.applyIosProject = applyIosProject;
async function writePackageJson(cliConfig, appRootDir, projectName, libraries) {
    const copyPacakge = await (0, fs_1.readJSON)(path.join(cliConfig.embedDir, 'package.base.json'), { encoding: 'utf-8' });
    copyPacakge.name = projectName;
    copyPacakge.devDependencies[`${definition_1.PACKAGE_GROUP_NAME}/cli`] = cliConfig.package.version;
    // copyPacakge.devDependencies['@morpheus/cli'] = '../'
    for (const { name, version } of libraries) {
        copyPacakge.dependencies[name] = version;
    }
    await (0, fs_1.writeFile)(path.join(appRootDir, 'package.json'), JSON.stringify(copyPacakge, null, 2), { encoding: 'utf-8' });
}
exports.writePackageJson = writePackageJson;
async function writeNpmrc(cliConfig, appRootDir) {
    await (0, fs_1.writeFile)(path.join(appRootDir, '.npmrc'), `${definition_1.PACKAGE_GROUP_NAME}:registry=${cliConfig.npmRegistryUrl} ${cliConfig.disabledTLSCerts ? '\nstrict-ssl=false \nalways-auth=false' : ''}`);
}
exports.writeNpmrc = writeNpmrc;
async function applyAndroidAppIcon(androidRootDir, icons) {
    const resDir = path.join(androidRootDir, 'src', 'main', 'res');
    for (const icon of icons) {
        const destDir = path.join(resDir, `drawable-${icon.density}`);
        if (!(await (0, fs_1.pathExists)(destDir)))
            await (0, fs_1.mkdirp)(destDir);
        const filename = icon.imgPath.split(path.sep).pop() || '';
        const fileext = filename.split('.').pop();
        await (0, fs_1.copy)(icon.imgPath, path.join(destDir, `icon.${fileext}`));
    }
}
exports.applyAndroidAppIcon = applyAndroidAppIcon;
async function applyIosAppIcon(iosRootDir, imgPath) {
    const assetDir = path.join(iosRootDir, 'Supporting Files', 'Assets.xcassets', 'AppIcon.appiconset');
    const filename = imgPath.split(path.sep).pop() || '';
    const fileext = filename.split('.').pop();
    const iconName = 'icon';
    const jsonFile = path.join(assetDir, 'Contents.json');
    if (!(await (0, fs_1.pathExists)(assetDir)))
        await (0, fs_1.mkdirp)(assetDir);
    await (0, fs_1.copy)(imgPath, path.join(assetDir, `${iconName}.${fileext}`));
    await (0, fs_1.writeFile)(jsonFile, JSON.stringify(INIT_XCODE_APPICON_CONTENTSJSON(`${iconName}.${fileext}`), null, 2), {
        encoding: 'utf-8',
    });
}
exports.applyIosAppIcon = applyIosAppIcon;
async function applyAppStartPage(manifestFile, startPage) {
    if (!(await (0, fs_1.pathExists)(manifestFile)))
        throw new errors_1.FatalException(`can not found ${manifestFile}. \n`);
    let content = await (0, fs_1.readFile)(manifestFile, { encoding: 'utf-8' });
    const regex = /<name>[\S\s]*?<\/name>/;
    content = content.replace(regex, `<name>${startPage}</name>`);
    await (0, fs_1.writeFile)(manifestFile, content, { encoding: 'utf-8' });
}
exports.applyAppStartPage = applyAppStartPage;
const INIT_XCODE_APPICON_CONTENTSJSON = (filename) => ({
    images: [
        {
            filename,
            idiom: 'universal',
            platform: 'ios',
            size: '1024x1024',
        },
    ],
    info: {
        author: 'xcode',
        version: 1,
    },
});
