"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@oclif/core");
const subprocess_1 = require("../lib/utils/subprocess");
const definition_1 = require("../definition");
class Sync extends core_1.Command {
    async run() {
        try {
            const { loadConfig, loadCliConfig } = await Promise.resolve().then(() => require('../lib/config'));
            const cliConfig = await loadCliConfig();
            const config = await loadConfig();
            const { applyAndroidLibrary, applyIosLibrary, applyLegacyWebLibrary, syncLibraryManifest } = await Promise.resolve().then(() => require('../lib/library'));
            await applyAndroidLibrary(config);
            await applyIosLibrary(config);
            await applyLegacyWebLibrary(config);
            await syncLibraryManifest(config);
            // window의 경우 podinstall 안함.
            if (cliConfig.os !== definition_1.OS.Mac || !config.ios)
                return;
            try {
                const cmd = new subprocess_1.Subprocess('pod', ['install'], { stdio: 'inherit', cwd: config.ios.rootDir });
                await cmd.run();
            }
            catch {
                this.log(`can not execute command pod check your $PATH and Terminal Program`);
            }
        }
        catch (e) {
            this.error(e);
        }
    }
}
exports.default = Sync;
Sync.description = 'Sync Morpheus Project';
Sync.examples = ['<%= config.bin %> <%= command.id %>'];
Sync.flags = {
// flag with a value (-n, --name=VALUE)
// name: Flags.string({ char: 'n', description: 'name to print' }),
// flag with no value (-f, --force)
// force: Flags.boolean({ char: 'f' }),
};
Sync.args = {
// file: Args.string({ description: 'file to read' }),
};
