"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("node:path");
const core_1 = require("@oclif/core");
const errors_1 = require("../errors");
const fs_1 = require("../lib/utils/fs");
const prompt_1 = require("../lib/prompt");
const subprocess_1 = require("../lib/utils/subprocess");
const guards_1 = require("../guards");
class Create extends core_1.Command {
    async _existProject(destDir, force) {
        if (await (0, fs_1.pathExists)(destDir)) {
            if (force || (await (0, prompt_1.confirm)('해당 경로에 이미 폴더가 존재합니다. 삭제하시고 진행하시겠습니까?'))) {
                await (0, fs_1.remove)(destDir);
            }
            else {
                this.exit();
            }
        }
    }
    async _promptValues(cliConfig) {
        const { choiceAndroidCpus, choiceAppLicense } = await Promise.resolve().then(() => require('../lib/license'));
        const { loadLibraries, promptLibraries } = await Promise.resolve().then(() => require('../lib/library'));
        const { choiceTemplate } = await Promise.resolve().then(() => require('../lib/project'));
        const license = await choiceAppLicense(cliConfig);
        const cpus = await choiceAndroidCpus();
        const appName = await (0, prompt_1.promptAppName)();
        const libraries = await loadLibraries(cliConfig);
        const chooses = await promptLibraries('라이브러리 선택', libraries);
        const template = await choiceTemplate(cliConfig);
        return {
            license,
            cpus,
            iosAppName: appName,
            androidAppName: appName,
            template: template,
            libraries: chooses,
        };
    }
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    _guardIcons(value) {
        const icons = {};
        if (!value) {
            return icons;
        }
        if (value.ios && typeof value.ios === 'string') {
            icons.ios = value.ios;
        }
        if (Array.isArray(value.android) && value.android.some((v) => (0, guards_1.isAndroidAppIcon)(v))) {
            icons.android = value.android;
        }
        return icons;
    }
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    _guardValues(value, config) {
        const { androidAppName, cpus, libraries, template, license, templateProvider, iosAppName } = value;
        if (typeof androidAppName === 'string' &&
            typeof template === 'string' &&
            typeof license === 'string' &&
            Array.isArray(cpus) &&
            cpus.some((v) => (0, guards_1.isAndroidCpu)(v)) &&
            Array.isArray(libraries) &&
            libraries.some((v) => (0, guards_1.isNpmAsset)(v))) {
            let provider = config.template.mode;
            if (templateProvider === 'gitea' || templateProvider === 'npm') {
                provider = templateProvider;
            }
            if (provider === 'all')
                provider = 'gitea';
            return { androidAppName, iosAppName: iosAppName || androidAppName, cpus, libraries, template: { name: template, provider } };
        }
        throw new Error('Validation Error : --config VALUE Not Passed.');
    }
    async run() {
        const { args: { projectName }, flags: { config: optConfig, force }, } = await this.parse(Create);
        try {
            // internet check
            const destDir = path.join(process.cwd(), projectName);
            const jsonConfig = optConfig && JSON.parse(optConfig);
            await this._existProject(destDir, jsonConfig || force);
            const { loadCliConfig, writeExtConfig, defaultAndroidRoot, defaultIosRoot, defaultAssetsDir, loadExtConfig, CONFIG_FILE_NAME_JSON } = await Promise.resolve().then(() => require('../lib/config'));
            const { applyAndroidLicense, applyWebLicense, applyIosLicense, getLicenseByAppId } = await Promise.resolve().then(() => require('../lib/license'));
            const { checkInternetConnectivity } = await Promise.resolve().then(() => require('../lib/utils/network'));
            const { installTemplate, applyIosProject, writePackageJson, writeNpmrc, applyAndroidAppIcon, applyIosAppIcon, applyAppStartPage, applyAndroidAppName, applyIosAppName, } = await Promise.resolve().then(() => require('../lib/project'));
            const cliConfig = await loadCliConfig();
            await checkInternetConnectivity(cliConfig);
            const { license, cpus, androidAppName, libraries, template, iosAppName } = jsonConfig
                ? { ...this._guardValues(jsonConfig, cliConfig), license: await getLicenseByAppId(cliConfig, jsonConfig.license) }
                : await this._promptValues(cliConfig);
            const extConfig = {
                projectName,
                applicationId: license.appId,
                androidAppName,
                androidPackageName: license.packageName,
            };
            if (!(await (0, fs_1.pathExists)(destDir)))
                await (0, fs_1.mkdirp)(destDir);
            await writePackageJson(cliConfig, destDir, projectName, libraries);
            await writeNpmrc(cliConfig, destDir);
            await installTemplate(template, destDir, cliConfig);
            await applyAndroidAppName(defaultAndroidRoot(destDir), androidAppName);
            await applyAndroidLicense(cpus, defaultAndroidRoot(destDir), license, cliConfig);
            await applyWebLicense(defaultAssetsDir(destDir), license, cliConfig);
            const existIosProject = await (0, fs_1.pathExists)(defaultIosRoot(destDir));
            if (existIosProject) {
                extConfig.iosAppName = iosAppName;
                extConfig.iosBundleId = license.bundleId;
                await applyIosAppName(defaultIosRoot(destDir), iosAppName);
                await applyIosProject(defaultIosRoot(destDir), projectName);
                await applyIosLicense(defaultIosRoot(destDir), license, cliConfig);
            }
            let existExtConfig = {};
            if (await (0, fs_1.pathExists)(path.join(destDir, CONFIG_FILE_NAME_JSON))) {
                existExtConfig = await loadExtConfig(destDir);
            }
            await writeExtConfig({
                ...existExtConfig,
                ...extConfig,
            }, destDir);
            if (jsonConfig && typeof jsonConfig.startpage === 'string' && jsonConfig.startpage !== '') {
                await applyAppStartPage(path.join(defaultAssetsDir(destDir), 'res', 'Manifest.xml'), jsonConfig.startpage);
            }
            if (jsonConfig && jsonConfig.icons) {
                const icons = this._guardIcons(jsonConfig.icons);
                if (icons.android) {
                    await applyAndroidAppIcon(defaultAndroidRoot(destDir), icons.android);
                }
                if (existIosProject && icons.ios) {
                    await applyIosAppIcon(defaultIosRoot(destDir), icons.ios);
                }
            }
            try {
                const cmd = new subprocess_1.Subprocess(cliConfig.npmClient, ['install'], { stdio: 'inherit', cwd: destDir });
                await cmd.run();
            }
            catch {
                this.log(`can not execute command ${cliConfig.npmClient}\n command run: cd ${projectName} & ${cliConfig.npmClient} install`);
            }
            // package.json 생성처리 필요
        }
        catch (err) {
            if (err instanceof errors_1.NetworkException) {
                this.warn(`인터넷 상태 또는 방화벽을 확인해주세요.`);
            }
            this.error(err);
        }
    }
}
exports.default = Create;
Create.description = '모피어스 프로젝트 생성';
Create.examples = ['<%= config.bin %> <%= command.id %> MyApp'];
Create.flags = {
    // flag with a value (-n, --name=VALUE)
    // name: Flags.string({ char: 'n', description: 'name to print' }),
    // flag with no value (-f, --force)
    force: core_1.Flags.boolean({ char: 'f', default: false }),
    config: core_1.Flags.string({ char: 'c', description: 'Config in JSON format' }),
};
Create.args = {
    projectName: core_1.Args.string({
        description: 'Project Name',
        required: true,
    }),
};
